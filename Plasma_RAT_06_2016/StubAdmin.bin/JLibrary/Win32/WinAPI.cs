using System;
using System.Runtime.InteropServices;
using System.Text;

namespace JLibrary.Win32
{
	// Token: 0x0200003C RID: 60
	public static class WinAPI
	{
		// Token: 0x06000137 RID: 311
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

		// Token: 0x06000138 RID: 312
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr OpenThread(uint dwDesiredAccess, bool bInheritHandle, int dwThreadId);

		// Token: 0x06000139 RID: 313
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool CloseHandle(IntPtr handle);

		// Token: 0x0600013A RID: 314
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, int flAllocationType, int flProtect);

		// Token: 0x0600013B RID: 315
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool VirtualFreeEx(IntPtr hProcess, IntPtr lpAddress, int dwSize, int dwFreeType);

		// Token: 0x0600013C RID: 316
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flNewProtect, out uint flOldProtect);

		// Token: 0x0600013D RID: 317
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpAddress, byte[] lpBuffer, int dwSize, out uint lpNumberOfBytesRead);

		// Token: 0x0600013E RID: 318
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, out uint lpNumberOfBytesRead);

		// Token: 0x0600013F RID: 319
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr CreateRemoteThread(IntPtr hProcess, int lpThreadAttributes, int dwStackSize, IntPtr lpStartAddress, uint lpParameter, int dwCreationFlags, int lpThreadId);

		// Token: 0x06000140 RID: 320
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern IntPtr GetModuleHandleA(string lpModuleName);

		// Token: 0x06000141 RID: 321
		[DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

		// Token: 0x06000142 RID: 322
		[DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr GetProcAddress(IntPtr hModule, uint lpProcName);

		// Token: 0x06000143 RID: 323
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern uint WaitForSingleObject(IntPtr hObject, int dwTimeout);

		// Token: 0x06000144 RID: 324
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetExitCodeThread(IntPtr hThread, out uint lpExitCode);

		// Token: 0x06000145 RID: 325
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetThreadContext(IntPtr hThread, ref WinAPI.CONTEXT pContext);

		// Token: 0x06000146 RID: 326
		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetThreadContext(IntPtr hThread, ref WinAPI.CONTEXT pContext);

		// Token: 0x06000147 RID: 327
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern uint SuspendThread(IntPtr hThread);

		// Token: 0x06000148 RID: 328
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern uint ResumeThread(IntPtr hThread);

		// Token: 0x06000149 RID: 329
		[DllImport("kernel32.dll", SetLastError = true)]
		public static extern int GetProcessId(IntPtr hProcess);

		// Token: 0x0600014A RID: 330 RVA: 0x0000E9F0 File Offset: 0x0000CBF0
		public static uint GetLastErrorEx(IntPtr hProcess)
		{
			IntPtr procAddress = WinAPI.GetProcAddress(WinAPI.GetModuleHandleA("kernel32.dll"), "GetLastError");
			return WinAPI.RunThread(hProcess, procAddress, 0u, 1000);
		}

		// Token: 0x0600014B RID: 331 RVA: 0x0000EA20 File Offset: 0x0000CC20
		public static byte[] ReadRemoteMemory(IntPtr hProc, IntPtr address, uint len)
		{
			byte[] array = new byte[len];
			uint num = 0u;
			if (!WinAPI.ReadProcessMemory(hProc, address, array, array.Length, out num) || num != len)
			{
				array = null;
			}
			return array;
		}

		// Token: 0x0600014C RID: 332 RVA: 0x0000EA50 File Offset: 0x0000CC50
		public static uint RunThread(IntPtr hProcess, IntPtr lpStartAddress, uint lpParam, int timeout = 1000)
		{
			uint maxValue = uint.MaxValue;
			IntPtr intPtr = WinAPI.CreateRemoteThread(hProcess, 0, 0, lpStartAddress, lpParam, 0, 0);
			if (intPtr != IntPtr.Zero && (ulong)WinAPI.WaitForSingleObject(intPtr, timeout) == 0UL)
			{
				WinAPI.GetExitCodeThread(intPtr, out maxValue);
			}
			return maxValue;
		}

		// Token: 0x0600014D RID: 333 RVA: 0x0000EA98 File Offset: 0x0000CC98
		public static IntPtr ReadRemotePointer(IntPtr hProcess, IntPtr pData)
		{
			IntPtr zero = IntPtr.Zero;
			byte[] value;
			if (!hProcess.IsNull() && !pData.IsNull() && (value = WinAPI.ReadRemoteMemory(hProcess, pData, (uint)IntPtr.Size)) != null)
			{
				zero = new IntPtr(BitConverter.ToInt32(value, 0));
			}
			return zero;
		}

		// Token: 0x0600014E RID: 334 RVA: 0x0000EADC File Offset: 0x0000CCDC
		public static IntPtr GetModuleHandleEx(IntPtr hProcess, string lpModuleName)
		{
			IntPtr procAddress = WinAPI.GetProcAddress(WinAPI.GetModuleHandleA("kernel32.dll"), "GetModuleHandleW");
			IntPtr result = IntPtr.Zero;
			if (!procAddress.IsNull())
			{
				IntPtr intPtr = WinAPI.CreateRemotePointer(hProcess, Encoding.Unicode.GetBytes(lpModuleName + "\0"), 4);
				if (!intPtr.IsNull())
				{
					result = Win32Ptr.Create((long)((ulong)WinAPI.RunThread(hProcess, procAddress, (uint)intPtr.ToInt32(), 1000)));
					WinAPI.VirtualFreeEx(hProcess, intPtr, 0, 32768);
				}
			}
			return result;
		}

		// Token: 0x0600014F RID: 335 RVA: 0x0000EB5C File Offset: 0x0000CD5C
		public static IntPtr CreateRemotePointer(IntPtr hProcess, byte[] pData, int flProtect)
		{
			IntPtr intPtr = IntPtr.Zero;
			if (pData != null && hProcess != IntPtr.Zero)
			{
				intPtr = WinAPI.VirtualAllocEx(hProcess, IntPtr.Zero, (uint)pData.Length, 12288, flProtect);
				uint num = 0u;
				if ((intPtr == IntPtr.Zero || !WinAPI.WriteProcessMemory(hProcess, intPtr, pData, pData.Length, out num) || (ulong)num != (ulong)((long)pData.Length)) && intPtr != IntPtr.Zero)
				{
					WinAPI.VirtualFreeEx(hProcess, intPtr, 0, 32768);
					intPtr = IntPtr.Zero;
				}
			}
			return intPtr;
		}

		// Token: 0x06000150 RID: 336 RVA: 0x0000EBDC File Offset: 0x0000CDDC
		public static IntPtr GetProcAddressEx(IntPtr hProc, IntPtr hModule, object lpProcName)
		{
			IntPtr result = IntPtr.Zero;
			byte[] array = WinAPI.ReadRemoteMemory(hProc, hModule, 64u);
			if (array != null && BitConverter.ToUInt16(array, 0) == 23117)
			{
				uint num = BitConverter.ToUInt32(array, 60);
				if (num > 0u)
				{
					byte[] array2 = WinAPI.ReadRemoteMemory(hProc, hModule.Add((long)((ulong)num)), 264u);
					if (array2 != null && BitConverter.ToUInt32(array2, 0) == 17744u)
					{
						uint num2 = BitConverter.ToUInt32(array2, 120);
						uint num3 = BitConverter.ToUInt32(array2, 124);
						if (num2 > 0u && num3 > 0u)
						{
							byte[] array3 = WinAPI.ReadRemoteMemory(hProc, hModule.Add((long)((ulong)num2)), 40u);
							uint num4 = BitConverter.ToUInt32(array3, 28);
							uint num5 = BitConverter.ToUInt32(array3, 36);
							uint num6 = BitConverter.ToUInt32(array3, 20);
							int num7 = -1;
							if (num4 > 0u && num5 > 0u)
							{
								if (lpProcName.GetType().Equals(typeof(string)))
								{
									int num8 = WinAPI.SearchExports(hProc, hModule, array3, (string)lpProcName);
									if (num8 > -1)
									{
										byte[] array4 = WinAPI.ReadRemoteMemory(hProc, hModule.Add((long)((ulong)num5 + (ulong)((long)((long)num8 << 1)))), 2u);
										num7 = ((array4 == null) ? -1 : ((int)BitConverter.ToUInt16(array4, 0)));
									}
								}
								else if (lpProcName.GetType().Equals(typeof(short)) || lpProcName.GetType().Equals(typeof(ushort)))
								{
									num7 = int.Parse(lpProcName.ToString());
								}
								if (num7 > -1 && (long)num7 < (long)((ulong)num6))
								{
									byte[] array5 = WinAPI.ReadRemoteMemory(hProc, hModule.Add((long)((ulong)num4 + (ulong)((long)((long)num7 << 2)))), 4u);
									if (array5 != null)
									{
										uint num9 = BitConverter.ToUInt32(array5, 0);
										if (num9 >= num2 && num9 < num2 + num3)
										{
											string text = WinAPI.ReadRemoteString(hProc, hModule.Add((long)((ulong)num9)), null);
											if (!string.IsNullOrEmpty(text) && text.Contains("."))
											{
												result = WinAPI.GetProcAddressEx(hProc, WinAPI.GetModuleHandleEx(hProc, text.Split(new char[]
												{
													'.'
												})[0]), text.Split(new char[]
												{
													'.'
												})[1]);
											}
										}
										else
										{
											result = hModule.Add((long)((ulong)num9));
										}
									}
								}
							}
						}
					}
				}
			}
			return result;
		}

		// Token: 0x06000151 RID: 337 RVA: 0x0000EE14 File Offset: 0x0000D014
		private static int SearchExports(IntPtr hProcess, IntPtr hModule, byte[] exports, string name)
		{
			uint num = BitConverter.ToUInt32(exports, 24);
			uint num2 = BitConverter.ToUInt32(exports, 32);
			int num3 = -1;
			if (num > 0u && num2 > 0u)
			{
				byte[] array = WinAPI.ReadRemoteMemory(hProcess, hModule.Add((long)((ulong)num2)), num << 2);
				if (array != null)
				{
					uint[] array2 = new uint[num];
					for (int i = 0; i < array2.Length; i++)
					{
						array2[i] = BitConverter.ToUInt32(array, i << 2);
					}
					int num4 = 0;
					int num5 = array2.Length - 1;
					string text = string.Empty;
					while (num4 >= 0 && num4 <= num5)
					{
						if (num3 != -1)
						{
							break;
						}
						int num6 = (num4 + num5) / 2;
						text = WinAPI.ReadRemoteString(hProcess, hModule.Add((long)((ulong)array2[num6])), null);
						if (text.Equals(name))
						{
							num3 = num6;
						}
						else if (string.CompareOrdinal(text, name) < 0)
						{
							num4 = num6 - 1;
						}
						else
						{
							num5 = num6 + 1;
						}
					}
				}
			}
			return num3;
		}

		// Token: 0x06000152 RID: 338 RVA: 0x0000EEF8 File Offset: 0x0000D0F8
		public static string ReadRemoteString(IntPtr hProcess, IntPtr lpAddress, Encoding encoding = null)
		{
			if (encoding == null)
			{
				encoding = Encoding.ASCII;
			}
			StringBuilder stringBuilder = new StringBuilder();
			byte[] array = new byte[256];
			uint num = 0u;
			int num2 = -1;
			while (num2 < 0 && WinAPI.ReadProcessMemory(hProcess, lpAddress, array, array.Length, out num) && num > 0u)
			{
				lpAddress = lpAddress.Add((long)((ulong)num));
				int length = stringBuilder.Length;
				stringBuilder.Append(encoding.GetString(array, 0, (int)num));
				num2 = stringBuilder.ToString().IndexOf('\0', length);
			}
			return stringBuilder.ToString().Substring(0, num2);
		}

		// Token: 0x0200005E RID: 94
		public struct FLOATING_SAVE_AREA
		{
			// Token: 0x040001B9 RID: 441
			public uint ControlWord;

			// Token: 0x040001BA RID: 442
			public uint StatusWord;

			// Token: 0x040001BB RID: 443
			public uint TagWord;

			// Token: 0x040001BC RID: 444
			public uint ErrorOffset;

			// Token: 0x040001BD RID: 445
			public uint ErrorSelector;

			// Token: 0x040001BE RID: 446
			public uint DataOffset;

			// Token: 0x040001BF RID: 447
			public uint DataSelector;

			// Token: 0x040001C0 RID: 448
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
			public byte[] RegisterArea;

			// Token: 0x040001C1 RID: 449
			public uint Cr0NpxState;
		}

		// Token: 0x0200005F RID: 95
		public struct CONTEXT
		{
			// Token: 0x040001C2 RID: 450
			public uint ContextFlags;

			// Token: 0x040001C3 RID: 451
			public uint Dr0;

			// Token: 0x040001C4 RID: 452
			public uint Dr1;

			// Token: 0x040001C5 RID: 453
			public uint Dr2;

			// Token: 0x040001C6 RID: 454
			public uint Dr3;

			// Token: 0x040001C7 RID: 455
			public uint Dr6;

			// Token: 0x040001C8 RID: 456
			public uint Dr7;

			// Token: 0x040001C9 RID: 457
			public WinAPI.FLOATING_SAVE_AREA FloatSave;

			// Token: 0x040001CA RID: 458
			public uint SegGs;

			// Token: 0x040001CB RID: 459
			public uint SegFs;

			// Token: 0x040001CC RID: 460
			public uint SegEs;

			// Token: 0x040001CD RID: 461
			public uint SegDs;

			// Token: 0x040001CE RID: 462
			public uint Edi;

			// Token: 0x040001CF RID: 463
			public uint Esi;

			// Token: 0x040001D0 RID: 464
			public uint Ebx;

			// Token: 0x040001D1 RID: 465
			public uint Edx;

			// Token: 0x040001D2 RID: 466
			public uint Ecx;

			// Token: 0x040001D3 RID: 467
			public uint Eax;

			// Token: 0x040001D4 RID: 468
			public uint Ebp;

			// Token: 0x040001D5 RID: 469
			public uint Eip;

			// Token: 0x040001D6 RID: 470
			public uint SegCs;

			// Token: 0x040001D7 RID: 471
			public uint EFlags;

			// Token: 0x040001D8 RID: 472
			public uint Esp;

			// Token: 0x040001D9 RID: 473
			public uint SegSs;

			// Token: 0x040001DA RID: 474
			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
			public byte[] ExtendedRegisters;
		}
	}
}
