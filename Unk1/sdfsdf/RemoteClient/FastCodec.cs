using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Security;
using RemoteClient.Polices;

namespace RemoteClient
{
	// Token: 0x0200000B RID: 11
	[SuppressUnmanagedCodeSecurity]
	public class FastCodec
	{
		// Token: 0x0600000E RID: 14
		[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
		public unsafe static extern int memcmp(byte* ptr1, byte* ptr2, uint count);

		// Token: 0x0600000F RID: 15
		[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
		public static extern int memcmp(IntPtr ptr1, IntPtr ptr2, uint count);

		// Token: 0x06000010 RID: 16
		[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
		public static extern int memcpy(IntPtr dst, IntPtr src, uint count);

		// Token: 0x06000011 RID: 17
		[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
		public unsafe static extern int memcpy(byte* dst, byte* src, uint count);

		// Token: 0x06000012 RID: 18 RVA: 0x000022D3 File Offset: 0x000004D3
		public FastCodec(Size _s)
		{
			InvocationProcessPolicy.CompareError();
			base..ctor();
			this._Process = _s;
		}

		// Token: 0x06000013 RID: 19 RVA: 0x00002A2C File Offset: 0x00000C2C
		public unsafe void CodeImg(BitmapData newBmpdata, MemoryStream ms)
		{
			try
			{
				if (this.m_Predicate == 0u)
				{
					this.m_Predicate = (uint)(newBmpdata.Stride * this._Process.Height);
					this.listener = (byte*)((void*)Marshal.AllocHGlobal((IntPtr)((long)((ulong)this.m_Predicate))));
					FastCodec.memcpy(this.listener, (byte*)((void*)newBmpdata.Scan0), this.m_Predicate);
					using (Bitmap bitmap = new Bitmap(this._Process.Width, this._Process.Height, newBmpdata.Stride, PixelFormat.Format24bppRgb, (IntPtr)((void*)this.listener)))
					{
						bitmap.Save(ms, ImageFormat.Jpeg);
					}
					this._Specification = (int)ms.Length;
				}
				else
				{
					int num = 0;
					while ((long)(num + 90) <= (long)((ulong)this.m_Predicate))
					{
						if (FastCodec.memcmp(this.listener + num, (byte*)((void*)newBmpdata.Scan0) + num, 90u) != 0)
						{
							ms.Write(BitConverter.GetBytes(num), 0, 4);
							byte[] array = new byte[90];
							try
							{
								byte[] array2;
								byte* dst;
								if ((array2 = array) != null && array2.Length != 0)
								{
									dst = &array2[0];
								}
								else
								{
									dst = null;
								}
								FastCodec.memcpy(dst, (byte*)((void*)newBmpdata.Scan0) + num, 90u);
							}
							finally
							{
								byte[] array2 = null;
							}
							ms.Write(array, 0, array.Length);
						}
						num += 90;
					}
					FastCodec.memcpy(this.listener, (byte*)((void*)newBmpdata.Scan0), this.m_Predicate);
					if (ms.Length > (long)this._Specification)
					{
						ms.SetLength(0L);
						ms.Write(new byte[]
						{
							78,
							69,
							87,
							66,
							77,
							80
						}, 0, 6);
						using (Bitmap bitmap2 = new Bitmap(this._Process.Width, this._Process.Height, newBmpdata.Stride, PixelFormat.Format24bppRgb, (IntPtr)((void*)this.listener)))
						{
							bitmap2.Save(ms, ImageFormat.Jpeg);
						}
						this._Specification = (int)ms.Length;
					}
				}
			}
			catch
			{
			}
		}

		// Token: 0x06000014 RID: 20 RVA: 0x000022E7 File Offset: 0x000004E7
		public unsafe void Dispose()
		{
			Marshal.FreeHGlobal((IntPtr)((void*)this.listener));
		}

		// Token: 0x04000024 RID: 36
		private unsafe byte* listener;

		// Token: 0x04000025 RID: 37
		private Size _Process;

		// Token: 0x04000026 RID: 38
		private uint m_Predicate;

		// Token: 0x04000027 RID: 39
		private int _Specification;
	}
}
