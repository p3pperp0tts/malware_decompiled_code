using System;
using JLibrary.PortableExecutable;
using JLibrary.Tools;
using JLibrary.Win32;

namespace InjectionLibrary
{
	// Token: 0x02000035 RID: 53
	public abstract class InjectionMethod : ErrorBase
	{
		// Token: 0x17000010 RID: 16
		// (get) Token: 0x060000FB RID: 251 RVA: 0x0000275E File Offset: 0x0000095E
		// (set) Token: 0x060000FC RID: 252 RVA: 0x00002766 File Offset: 0x00000966
		public InjectionMethodType Type { get; protected set; }

		// Token: 0x060000FD RID: 253
		public abstract IntPtr Inject(string dllPath, IntPtr hProcess);

		// Token: 0x060000FE RID: 254 RVA: 0x0000C8B0 File Offset: 0x0000AAB0
		public virtual IntPtr Inject(string dllPath, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			IntPtr result = this.Inject(dllPath, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x060000FF RID: 255
		public abstract IntPtr[] InjectAll(string[] dllPaths, IntPtr hProcess);

		// Token: 0x06000100 RID: 256 RVA: 0x0000C8E4 File Offset: 0x0000AAE4
		public virtual IntPtr[] InjectAll(string[] dllPaths, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			IntPtr[] result = this.InjectAll(dllPaths, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x06000101 RID: 257
		public abstract IntPtr Inject(PortableExecutable image, IntPtr hProcess);

		// Token: 0x06000102 RID: 258 RVA: 0x0000C918 File Offset: 0x0000AB18
		public virtual IntPtr Inject(PortableExecutable image, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			IntPtr result = this.Inject(image, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x06000103 RID: 259
		public abstract IntPtr[] InjectAll(PortableExecutable[] images, IntPtr hProcess);

		// Token: 0x06000104 RID: 260 RVA: 0x0000C94C File Offset: 0x0000AB4C
		public virtual IntPtr[] InjectAll(PortableExecutable[] images, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			IntPtr[] result = this.InjectAll(images, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x06000105 RID: 261
		public abstract bool Unload(IntPtr hModule, IntPtr hProcess);

		// Token: 0x06000106 RID: 262 RVA: 0x0000C980 File Offset: 0x0000AB80
		public virtual bool Unload(IntPtr hModule, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			bool result = this.Unload(hModule, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x06000107 RID: 263
		public abstract bool[] UnloadAll(IntPtr[] hModules, IntPtr hProcess);

		// Token: 0x06000108 RID: 264 RVA: 0x0000C9B4 File Offset: 0x0000ABB4
		public virtual bool[] UnloadAll(IntPtr[] hModules, int processId)
		{
			this.ClearErrors();
			IntPtr intPtr = WinAPI.OpenProcess(1082u, false, processId);
			bool[] result = this.UnloadAll(hModules, intPtr);
			WinAPI.CloseHandle(intPtr);
			return result;
		}

		// Token: 0x06000109 RID: 265 RVA: 0x0000C9E8 File Offset: 0x0000ABE8
		public static InjectionMethod Create(InjectionMethodType type)
		{
			InjectionMethod injectionMethod;
			switch (type)
			{
			case InjectionMethodType.Standard:
				injectionMethod = new CRTInjection();
				break;
			case InjectionMethodType.ThreadHijack:
				injectionMethod = new ThreadHijack();
				break;
			case InjectionMethodType.ManualMap:
				injectionMethod = new ManualMap();
				break;
			default:
				return null;
			}
			if (injectionMethod != null)
			{
				injectionMethod.Type = type;
			}
			return injectionMethod;
		}
	}
}
