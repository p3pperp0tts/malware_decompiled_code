using System;
using System.Collections.Generic;
using System.IO;
using JLibrary.Tools;

namespace JLibrary.PortableExecutable
{
	// Token: 0x0200003F RID: 63
	[Serializable]
	public class PortableExecutable : MemoryIterator
	{
		// Token: 0x17000012 RID: 18
		// (get) Token: 0x06000156 RID: 342 RVA: 0x000028C4 File Offset: 0x00000AC4
		// (set) Token: 0x06000157 RID: 343 RVA: 0x000028CC File Offset: 0x00000ACC
		public IMAGE_NT_HEADER32 NTHeader { get; private set; }

		// Token: 0x17000013 RID: 19
		// (get) Token: 0x06000158 RID: 344 RVA: 0x000028D5 File Offset: 0x00000AD5
		// (set) Token: 0x06000159 RID: 345 RVA: 0x000028DD File Offset: 0x00000ADD
		public IMAGE_DOS_HEADER DOSHeader { get; private set; }

		// Token: 0x17000014 RID: 20
		// (get) Token: 0x0600015A RID: 346 RVA: 0x000028E6 File Offset: 0x00000AE6
		// (set) Token: 0x0600015B RID: 347 RVA: 0x000028EE File Offset: 0x00000AEE
		public string FileLocation { get; private set; }

		// Token: 0x0600015C RID: 348 RVA: 0x000028F7 File Offset: 0x00000AF7
		public PortableExecutable(string path) : this(File.ReadAllBytes(path))
		{
			this.FileLocation = path;
		}

		// Token: 0x0600015D RID: 349 RVA: 0x0000F00C File Offset: 0x0000D20C
		public PortableExecutable(byte[] data) : base(data)
		{
			string text = string.Empty;
			IMAGE_NT_HEADER32 ntheader = default(IMAGE_NT_HEADER32);
			IMAGE_DOS_HEADER dosheader = default(IMAGE_DOS_HEADER);
			if (base.Read<IMAGE_DOS_HEADER>(out dosheader) && dosheader.e_magic == 23117)
			{
				if (base.Read<IMAGE_NT_HEADER32>((long)((ulong)dosheader.e_lfanew), SeekOrigin.Begin, out ntheader) && (long)ntheader.Signature == 17744L)
				{
					if (ntheader.OptionalHeader.Magic == 267)
					{
						if (ntheader.OptionalHeader.DataDirectory[14].Size > 0u)
						{
							text = "Image contains a CLR runtime header. Currently only native binaries are supported; no .NET dependent libraries.";
						}
					}
					else
					{
						text = "File is of the PE32+ format. Currently support only extends to PE32 images. Either recompile the binary as x86, or choose a different target.";
					}
				}
				else
				{
					text = "Invalid NT header found in image.";
				}
			}
			else
			{
				text = "Invalid DOS Header found in image";
			}
			if (!string.IsNullOrEmpty(text))
			{
				base.Dispose();
				throw new ArgumentException(text);
			}
			this.NTHeader = ntheader;
			this.DOSHeader = dosheader;
		}

		// Token: 0x0600015E RID: 350 RVA: 0x0000F0E4 File Offset: 0x0000D2E4
		public IEnumerable<IMAGE_SECTION_HEADER> EnumSectionHeaders()
		{
			PortableExecutable.<EnumSectionHeaders>d__0 <EnumSectionHeaders>d__ = new PortableExecutable.<EnumSectionHeaders>d__0(-2);
			<EnumSectionHeaders>d__.<>4__this = this;
			return <EnumSectionHeaders>d__;
		}

		// Token: 0x0600015F RID: 351 RVA: 0x0000F104 File Offset: 0x0000D304
		public IEnumerable<IMAGE_IMPORT_DESCRIPTOR> EnumImports()
		{
			IMAGE_DATA_DIRECTORY impDir = this.NTHeader.OptionalHeader.DataDirectory[1];
			if (impDir.Size > 0u)
			{
				uint pDesc = this.GetPtrFromRVA(impDir.VirtualAddress);
				uint szDesc = typeof(IMAGE_IMPORT_DESCRIPTOR).SizeOf();
				IMAGE_IMPORT_DESCRIPTOR desc;
				while (base.Read<IMAGE_IMPORT_DESCRIPTOR>((long)((ulong)pDesc), SeekOrigin.Begin, out desc) && desc.OriginalFirstThunk > 0u && desc.Name > 0u)
				{
					yield return desc;
					pDesc += szDesc;
				}
			}
			yield break;
		}

		// Token: 0x06000160 RID: 352 RVA: 0x0000290C File Offset: 0x00000B0C
		public byte[] ToArray()
		{
			return base.GetUnderlyingData();
		}

		// Token: 0x06000161 RID: 353 RVA: 0x0000F124 File Offset: 0x0000D324
		private IMAGE_SECTION_HEADER GetEnclosingSectionHeader(uint rva)
		{
			foreach (IMAGE_SECTION_HEADER result in this.EnumSectionHeaders())
			{
				if (rva >= result.VirtualAddress && rva < result.VirtualAddress + ((result.VirtualSize > 0u) ? result.VirtualSize : result.SizeOfRawData))
				{
					return result;
				}
			}
			throw new EntryPointNotFoundException("RVA does not exist within any of the current sections.");
		}

		// Token: 0x06000162 RID: 354 RVA: 0x0000F1AC File Offset: 0x0000D3AC
		public uint GetPtrFromRVA(uint rva)
		{
			IMAGE_SECTION_HEADER enclosingSectionHeader = this.GetEnclosingSectionHeader(rva);
			return rva - (enclosingSectionHeader.VirtualAddress - enclosingSectionHeader.PointerToRawData);
		}
	}
}
