using System;
using System.Runtime.InteropServices;

namespace JLibrary.Tools
{
	// Token: 0x02000026 RID: 38
	[Serializable]
	public class UnmanagedBuffer : ErrorBase, IDisposable
	{
		// Token: 0x1700000E RID: 14
		// (get) Token: 0x060000E9 RID: 233 RVA: 0x00002618 File Offset: 0x00000818
		// (set) Token: 0x060000EA RID: 234 RVA: 0x00002620 File Offset: 0x00000820
		public IntPtr Pointer { get; private set; }

		// Token: 0x1700000F RID: 15
		// (get) Token: 0x060000EB RID: 235 RVA: 0x00002629 File Offset: 0x00000829
		// (set) Token: 0x060000EC RID: 236 RVA: 0x00002631 File Offset: 0x00000831
		public int Size { get; private set; }

		// Token: 0x060000ED RID: 237 RVA: 0x0000263A File Offset: 0x0000083A
		public UnmanagedBuffer(int cbneeded)
		{
			if (cbneeded > 0)
			{
				this.Pointer = Marshal.AllocHGlobal(cbneeded);
				this.Size = cbneeded;
				return;
			}
			this.Pointer = IntPtr.Zero;
			this.Size = 0;
		}

		// Token: 0x060000EE RID: 238 RVA: 0x0000266C File Offset: 0x0000086C
		public bool Commit(byte[] data, int index, int count)
		{
			if (data != null && this.Alloc(count))
			{
				Marshal.Copy(data, index, this.Pointer, count);
				return true;
			}
			if (data == null)
			{
				this.SetLastError(new ArgumentException("Attempting to commit a null reference", "data"));
			}
			return false;
		}

		// Token: 0x060000EF RID: 239 RVA: 0x0000C5B4 File Offset: 0x0000A7B4
		public bool Commit<T>(T data) where T : struct
		{
			bool result;
			try
			{
				if (this.Alloc(Marshal.SizeOf(typeof(T))))
				{
					Marshal.StructureToPtr(data, this.Pointer, false);
					result = true;
				}
				else
				{
					result = false;
				}
			}
			catch (Exception lastError)
			{
				result = this.SetLastError(lastError);
			}
			return result;
		}

		// Token: 0x060000F0 RID: 240 RVA: 0x0000C610 File Offset: 0x0000A810
		public bool SafeDecommit<T>() where T : struct
		{
			bool result;
			try
			{
				if (this.Size < Marshal.SizeOf(typeof(T)))
				{
					throw new InvalidCastException("Not enough unmanaged memory is allocated to contain this structure type.");
				}
				Marshal.DestroyStructure(this.Pointer, typeof(T));
				result = true;
			}
			catch (Exception lastError)
			{
				result = this.SetLastError(lastError);
			}
			return result;
		}

		// Token: 0x060000F1 RID: 241 RVA: 0x0000C674 File Offset: 0x0000A874
		public bool Read<TResult>(out TResult data) where TResult : struct
		{
			data = default(TResult);
			bool result;
			try
			{
				if (this.Size < Marshal.SizeOf(typeof(TResult)))
				{
					throw new InvalidCastException("Not enough unmanaged memory is allocated to contain this structure type.");
				}
				data = (TResult)((object)Marshal.PtrToStructure(this.Pointer, typeof(TResult)));
				result = true;
			}
			catch (Exception lastError)
			{
				result = this.SetLastError(lastError);
			}
			return result;
		}

		// Token: 0x060000F2 RID: 242 RVA: 0x0000C6EC File Offset: 0x0000A8EC
		public byte[] Read(int count)
		{
			byte[] result;
			try
			{
				if (count > this.Size || count <= 0)
				{
					throw new ArgumentException("There is either not enough memory allocated to read 'count' bytes, or 'count' is negative (" + count.ToString() + ")", "count");
				}
				byte[] array = new byte[count];
				Marshal.Copy(this.Pointer, array, 0, count);
				result = array;
			}
			catch (Exception lastError)
			{
				this.SetLastError(lastError);
				result = null;
			}
			return result;
		}

		// Token: 0x060000F3 RID: 243 RVA: 0x000026A4 File Offset: 0x000008A4
		public bool Translate<TSource>(TSource data, out byte[] buffer) where TSource : struct
		{
			buffer = null;
			if (this.Commit<TSource>(data))
			{
				buffer = this.Read(Marshal.SizeOf(typeof(TSource)));
				this.SafeDecommit<TSource>();
			}
			return buffer != null;
		}

		// Token: 0x060000F4 RID: 244 RVA: 0x000026D8 File Offset: 0x000008D8
		public bool Translate<TResult>(byte[] buffer, out TResult result) where TResult : struct
		{
			result = default(TResult);
			if (buffer == null)
			{
				return this.SetLastError(new ArgumentException("Attempted to translate a null reference to a structure.", "buffer"));
			}
			return this.Commit(buffer, 0, buffer.Length) && this.Read<TResult>(out result);
		}

		// Token: 0x060000F5 RID: 245 RVA: 0x00002710 File Offset: 0x00000910
		public bool Translate<TSource, TResult>(TSource data, out TResult result) where TSource : struct where TResult : struct
		{
			result = default(TResult);
			return this.Commit<TSource>(data) && this.Read<TResult>(out result) && this.SafeDecommit<TSource>();
		}

		// Token: 0x060000F6 RID: 246 RVA: 0x0000C760 File Offset: 0x0000A960
		public bool Resize(int size)
		{
			if (size < 0)
			{
				return this.SetLastError(new ArgumentException("Attempting to resize to less than zero bytes of memory", "size"));
			}
			if (size == this.Size)
			{
				return true;
			}
			if (size > this.Size)
			{
				return this.Alloc(size);
			}
			bool result;
			try
			{
				if (size == 0)
				{
					Marshal.FreeHGlobal(this.Pointer);
					this.Pointer = IntPtr.Zero;
				}
				else if (size > 0)
				{
					this.Pointer = Marshal.ReAllocHGlobal(this.Pointer, new IntPtr(size));
				}
				this.Size = size;
				result = true;
			}
			catch (Exception lastError)
			{
				result = this.SetLastError(lastError);
			}
			return result;
		}

		// Token: 0x060000F7 RID: 247 RVA: 0x0000C800 File Offset: 0x0000AA00
		private bool Alloc(int cb)
		{
			bool result;
			try
			{
				if (cb > this.Size)
				{
					this.Pointer = ((this.Pointer == IntPtr.Zero) ? Marshal.AllocHGlobal(cb) : Marshal.ReAllocHGlobal(this.Pointer, new IntPtr(cb)));
					this.Size = cb;
				}
				result = true;
			}
			catch (Exception lastError)
			{
				result = this.SetLastError(lastError);
			}
			return result;
		}

		// Token: 0x060000F8 RID: 248 RVA: 0x00002733 File Offset: 0x00000933
		public void Dispose()
		{
			this.Dispose(true);
			GC.SuppressFinalize(this);
		}

		// Token: 0x060000F9 RID: 249 RVA: 0x00002742 File Offset: 0x00000942
		private void Dispose(bool disposing)
		{
			if (!this._disposed)
			{
				if (disposing)
				{
					this.Resize(0);
				}
				this._disposed = true;
			}
		}

		// Token: 0x0400008F RID: 143
		private bool _disposed;
	}
}
